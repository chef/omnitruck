#! /usr/bin/env ruby

require 'uber-s3'
require 'json'
require 'yaml'
require 'optparse'

class S3Poller

  def initialize
    @options = {}

    optparse = OptionParser.new do |opts|
      opts.banner = "Usage: #{$0} -e <environment>"

      opts.on_tail('-h', '--help', 'Print this help message') do
        puts opts
        exit
      end
      opts.on('-e ENVIRONMENT', 
              "Specify this application's environment - REQUIRED") do |e|
        @options[:environment] = e
      end
    end
    optparse.parse!

    @options[:config] = "./config/config.yml"

    required = [:environment, :config]
    missing = required.select { |opt| @options[opt].nil? }
    unless missing.empty?
      puts "[ERROR] Missing required options: #{missing.join(', ')}"
      puts optparse
      exit 1
    end

    unless File.exists?(@options[:config])
      puts "[ERROR] Config file could not be found at #{@options[:config]}"
      puts optparse
      exit 1
    end

    @config = YAML.load_file(@options[:config])[@options[:environment]]
    @platform_client_support = "/chef-platform-support"
    @platform_server_support = "/chef-server-platform-support"
    @human_redable_list = "/chef-platform-support/chef-platform-names.json"
    @human_redable_server_list = "/chef-platform-support/chef-server-platform-names.json"

    # Create S3 client
    @s3 = UberS3.new({
                       :access_key => @config['aws_access_key_id'],
                       :secret_access_key => @config['aws_secret_access_key'],
                       :bucket => @config['aws_bucket'],
                       :adapter => :net_http
                     })
  end

  # Define a deep merge for nested hashes
  def deep_merge(h1, h2)
    result = h1.dup
    h2.keys.each do |key|
      result[key] = if h1[key].is_a? Hash and h2[key].is_a? Hash
                      deep_merge(result[key], h2[key])
                    else
                      h2[key]
                    end
    end
    result
  end

  # Grabs the platform support json files from S3, merges them, and returns one big hash
  def get_artifacts(platform_support)
    result = Hash.new
    begin
      # This array contains the platform-support directory along with the JSON files,
      # so I need to get rid of the objects that aren't JSON files.
      support_files = @s3.objects(platform_support).to_a
      support_files.delete_if { |o| not o.key.match(/\.json/) }
      # We don't want to include any platform-names.json files, as these
      # contain info pertaining to human-readable names. Not relevent here.
      support_files.delete_if { |o| o.key.match("platform-names.json") }
      support_files.each do |support|
        hash = JSON.parse(support.value)
        result = deep_merge(result, hash)
      end
      result
    rescue UberS3::Error::Standard => e
      puts e.message
      puts <<EOF
[ERROR] Problem connecting to S3 using these credentials:
            aws access key id:      #{@config['aws_access_key_id']}
            aws secret access key:  #{@config['aws_secret_access_key']}
            bucket:                 #{@config['aws_bucket']}

Please check your credentials.
EOF
      exit
    end
  end

  # Run the S3 Poller, generating build_list.json and build_server_list.json
  def run
    build_json(@config['build_list'], @platform_client_support) 
    build_json(@config['build_server_list'], @platform_server_support)

    #Grab the human readable json files directly
    File.open(@config['human_readable_list'], "w") do |f|
      f.puts JSON.pretty_generate(JSON.parse(@s3.object(@human_readable_list).value))
    end
    File.open(@config['human_readable_server_list'], "w") do |f|
      f.puts JSON.pretty_generate(JSON.parse(@s3.object(@human_readable_server_list).value))
    end
  end

  # Builds the json and writes it to build_list_path
  def build_json(build_list_path, platform_support)
    File.open(build_list_path, "w") do |f|
      directory = get_artifacts(platform_support)
      # Timestamp used for the status page to make sure the list is up to date.
      directory['run_data'] = { :timestamp => Time.now.to_s }
      f.puts JSON.pretty_generate(directory)
    end
  end
end

if $0 == __FILE__
  S3Poller.new.run
end

exit
